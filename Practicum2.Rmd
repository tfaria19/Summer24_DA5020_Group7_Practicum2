---
title: "Practicum2"
author: "Thomas Faria, Caitlin Kirkpatrick, Sairah Shir"
date: "2024-07-14"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Load required packages for Practicum2
library(tidyverse)
library(readr)
library(RSQLite)

```

### Loading and data exploration

```{r, load}

# Load data
bed_type_df <- read_csv("data/bed_type.csv", show_col_types = FALSE)
bed_fact_df <- read_csv("data/bed_fact.csv", show_col_types = FALSE)
business_df <- read_csv("data/business.csv", show_col_types = FALSE)

```

```{r, explore}

# Explore data
print("Summary of bed_type.csv")
summary(bed_type_df)
print("Summary of bed_fact.csv")
summary(bed_fact_df)
print("Summary of business.csv")
summary(business_df)

# Outlier identification
# Compute outliers for each bed type in business_df
business_outliers <- business_df %>%
  mutate(
    mean_license_beds = mean(ttl_license_beds, na.rm = TRUE),
    mean_census_beds = mean(ttl_census_beds, na.rm = TRUE),
    mean_staffed_beds = mean(ttl_staffed_beds, na.rm = TRUE),
    sd_license_beds = sd(ttl_license_beds, na.rm = TRUE),
    sd_census_beds = sd(ttl_census_beds, na.rm = TRUE),
    sd_staffed_beds = sd(ttl_staffed_beds, na.rm = TRUE)
  ) %>%
  # Relative to the mean, any values on the lower or upper bounds that are 3 times the standard deviation are filtered
  filter(ttl_license_beds < mean_license_beds - 3 * sd_license_beds | ttl_license_beds > mean_license_beds + 3 * sd_license_beds) %>%
  filter(ttl_census_beds < mean_census_beds - 3 * sd_census_beds | ttl_census_beds > mean_census_beds + 3 * sd_census_beds) %>%
  filter(ttl_staffed_beds < mean_staffed_beds - 3 * sd_staffed_beds | ttl_staffed_beds > mean_staffed_beds + 3 * sd_staffed_beds) %>%
  select(ttl_license_beds, ttl_census_beds, ttl_staffed_beds)

business_outliers

# Remove outliers from dataset
rmv_business_outliers <- business_df %>%
  mutate(
    mean_license_beds = mean(ttl_license_beds, na.rm = TRUE),
    mean_census_beds = mean(ttl_census_beds, na.rm = TRUE),
    mean_staffed_beds = mean(ttl_staffed_beds, na.rm = TRUE),
    sd_license_beds = sd(ttl_license_beds, na.rm = TRUE),
    sd_census_beds = sd(ttl_census_beds, na.rm = TRUE),
    sd_staffed_beds = sd(ttl_staffed_beds, na.rm = TRUE)
  ) %>%
  # Relative to the mean, any values on the lower or upper bounds that are 3 times the standard deviation are filtered
  filter(!(ttl_license_beds < mean_license_beds - 3 * sd_license_beds | ttl_license_beds > mean_license_beds + 3 * sd_license_beds)) %>%
  filter(!(ttl_census_beds < mean_census_beds - 3 * sd_census_beds | ttl_census_beds > mean_census_beds + 3 * sd_census_beds)) %>%
  filter(!(ttl_staffed_beds < mean_staffed_beds - 3 * sd_staffed_beds | ttl_staffed_beds > mean_staffed_beds + 3 * sd_staffed_beds))

# Note subtracted outliers from new dataframe
str(business_df)
str(rmv_business_outliers)

# Basic histograms for outlier visualization
ggplot(bed_fact_df, aes(x = license_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of License Beds", y = "Frequency") +
  theme_minimal()

ggplot(bed_fact_df, aes(x = census_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of Census Beds", y = "Frequency") +
  theme_minimal()

ggplot(bed_fact_df, aes(x = staffed_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of Staffed Beds", y = "Frequency") +
  theme_minimal()

```

```{r, tidy}

# Tidy data if necessary

```

```{r, create_db}

# Add data to a new database for downstream SQL queries
# Establish and open connection to existing database file
p2_connection <- dbConnect(RSQLite::SQLite(), "p2_db.sqlite")

# Function to check if table already exists in p2_db
table_exists <- function(con, table_name) {
  query <- sprintf("SELECT name FROM sqlite_master WHERE type='table' AND name='%s';", table_name)
  result <- dbGetQuery(con, query)
  return(nrow(result) > 0)
}

# Create bed_type_table, if it doesn't already exist
if (!table_exists(p2_connection, "bed_type_table")) {
  dbExecute(p2_connection, "
                      CREATE TABLE bed_type_table (
                        bed_id INTEGER PRIMARY KEY,
                        bed_code TEXT,
                        bed_desc TEXT
                      )
          ")
}

# Create bed_fact_table, if it doesn't already exist
if (!table_exists(p2_connection, "bed_fact_table")) {
  dbExecute(p2_connection, "
                      CREATE TABLE bed_fact_table (
                        ims_org_id TEXT,
                        bed_id INTEGER,
                        license_beds INTEGER,
                        census_beds INTEGER,
                        staffed_beds INTEGER,
                        PRIMARY KEY (ims_org_id, bed_id)
                      )
          ")
}

# Create business_table, if it doesn't already exist
if (!table_exists(p2_connection, "business_table")) {
  dbExecute(p2_connection, "
                      CREATE TABLE business_table (
                        ims_org_id TEXT,
                        business_name TEXT,
                        ttl_license_beds INTEGER,
                        ttl_census_beds INTEGER,
                        ttl_staffed_beds INTEGER,
                        bed_cluster_id INTEGER,
                        PRIMARY KEY (ims_org_id, bed_cluster_id)
                      )
          ")
}

# Load data into each table
dbWriteTable(p2_connection, "bed_type_table", bed_type_df, overwrite = TRUE, row.names = FALSE)
dbWriteTable(p2_connection, "bed_fact_table", bed_fact_df, overwrite = TRUE, row.names = FALSE)
dbWriteTable(p2_connection, "business_table", business_df, overwrite = TRUE, row.names = FALSE)

```

```{r, check_composite_pks}

# Verify the uniqueness of the composite primary keys used in bed_fact_table (combination of ims_org_id and bed_id) and business_table (combination of ims_org_id and bed_cluster_id)

duplicate_keys <- dbGetQuery(connection, "
                             SELECT ims_org_id, bed_id, COUNT(*)
                             FROM bed_fact_table
                             GROUP BY ims_org_id, bed_id
                             HAVING COUNT(*) > 1;
                             ")

if (nrow(duplicate_keys) == 0) {
  print("Composite PK is unique for all combinations of ims_org_id and bed_id in bed_fact_table.")
} else {
  print("Duplicate keys found in bed_fact_table !! Composite PK is not valid.")
  print(duplicate_keys)
}

duplicate_keys <- dbGetQuery(connection, "
                             SELECT ims_org_id, bed_cluster_id, COUNT(*)
                             FROM business_table
                             GROUP BY ims_org_id, bed_cluster_id
                             HAVING COUNT(*) > 1;
                             ")

if (nrow(duplicate_keys) == 0) {
  print("Composite PK is unique for all combinations of ims_org_id and bed_cluster_id in business_table.")
} else {
  print("Duplicate keys found in business_table !! Composite PK is not valid.")
  print(duplicate_keys)
}

```

###  Identification of Dimensions in bed_type.csv and business.csv

```{r}
str(bed_type_df)
str(business_df)
```

* bed_type_df contains three dimensions that are qualitative attributes providing context for or categorizing a fact object:
  * bed_id (primary key) assigns a unique identifier for each type of bed
  * bed_code contains abbreviations for each type of bed
  * bed_desc contains descriptions of each type of bed

* business_df contains three dimensions that are qualitative attributes providing context for or categorizing a fact object:
  * ims_org_id (primary key) assigns a unique identifier for each business
  * business_name contains the names of the organizations
  * bed_cluster_id categorizes bed clusters from 1-9
* The remaining columns ttl_license_beds, ttl_census_beds, and ttl_staffed_beds are facts due to their quantitative nature 

### Identification of Fact Variables in bed_fact.csv

-   TODO

### Initial Analysis for Leadership

```{r, license_beds_separate}
# Thomas

```

```{r, census_beds_separate}
# Caitlin

```

```{r, staffed_beds_separate}
# Sairah

```

### Interpretation of Findings (Pt. 1)

TODO

### Follow-up Analysis for Leadership (identifying hospitals with both ICU and SICU volume sufficiency)

```{r, license_beds_combined}
# Thomas

```

```{r, census_beds_combined}
# Caitlin

```

```{r, staffed_beds_combined}
# Sairah

```

### Interpretation of Findings (Pt. 2)

TODO

### Final Recommendation

TODO
