---
title: "Practicum2"
author: "Thomas Faria, Caitlin Kirkpatrick, Sairah Shir"
date: "2024-07-14"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Load required packages for Practicum2
library(tidyverse)
library(readr)
library(RSQLite)

```

### Loading and data exploration

```{r, load}

# Load data
bed_type_df <- read_csv("data/bed_type.csv", show_col_types = FALSE)
bed_fact_df <- read_csv("data/bed_fact.csv", show_col_types = FALSE)
business_df <- read_csv("data/business.csv", show_col_types = FALSE)

```

```{r, explore}

# Explore data
print("Summary of bed_type.csv")
summary(bed_type_df)
print("Summary of bed_fact.csv")
summary(bed_fact_df)
print("Summary of business.csv")
summary(business_df)

# Outlier identification
# Compute outliers for each bed type in business_df
business_outliers <- business_df %>%
  mutate(
    mean_license_beds = mean(ttl_license_beds, na.rm = TRUE),
    mean_census_beds = mean(ttl_census_beds, na.rm = TRUE),
    mean_staffed_beds = mean(ttl_staffed_beds, na.rm = TRUE),
    sd_license_beds = sd(ttl_license_beds, na.rm = TRUE),
    sd_census_beds = sd(ttl_census_beds, na.rm = TRUE),
    sd_staffed_beds = sd(ttl_staffed_beds, na.rm = TRUE)
  ) %>%
  # Relative to the mean, any values on the lower or upper bounds that are 3 times the standard deviation are filtered
  filter(ttl_license_beds < mean_license_beds - 3 * sd_license_beds | ttl_license_beds > mean_license_beds + 3 * sd_license_beds) %>%
  filter(ttl_census_beds < mean_census_beds - 3 * sd_census_beds | ttl_census_beds > mean_census_beds + 3 * sd_census_beds) %>%
  filter(ttl_staffed_beds < mean_staffed_beds - 3 * sd_staffed_beds | ttl_staffed_beds > mean_staffed_beds + 3 * sd_staffed_beds) %>%
  select(ttl_license_beds, ttl_census_beds, ttl_staffed_beds)

business_outliers

# Remove outliers from dataset
rmv_business_outliers <- business_df %>%
  mutate(
    mean_license_beds = mean(ttl_license_beds, na.rm = TRUE),
    mean_census_beds = mean(ttl_census_beds, na.rm = TRUE),
    mean_staffed_beds = mean(ttl_staffed_beds, na.rm = TRUE),
    sd_license_beds = sd(ttl_license_beds, na.rm = TRUE),
    sd_census_beds = sd(ttl_census_beds, na.rm = TRUE),
    sd_staffed_beds = sd(ttl_staffed_beds, na.rm = TRUE)
  ) %>%
  # Relative to the mean, any values on the lower or upper bounds that are 3 times the standard deviation are filtered
  filter(!(ttl_license_beds < mean_license_beds - 3 * sd_license_beds | ttl_license_beds > mean_license_beds + 3 * sd_license_beds)) %>%
  filter(!(ttl_census_beds < mean_census_beds - 3 * sd_census_beds | ttl_census_beds > mean_census_beds + 3 * sd_census_beds)) %>%
  filter(!(ttl_staffed_beds < mean_staffed_beds - 3 * sd_staffed_beds | ttl_staffed_beds > mean_staffed_beds + 3 * sd_staffed_beds))

# Note subtracted outliers from new dataframe
str(business_df)
str(rmv_business_outliers)

# Basic histograms for outlier visualization
ggplot(bed_fact_df, aes(x = license_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of License Beds", y = "Frequency") +
  theme_minimal()

ggplot(bed_fact_df, aes(x = census_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of Census Beds", y = "Frequency") +
  theme_minimal()

ggplot(bed_fact_df, aes(x = staffed_beds)) +
  geom_histogram(binwidth = 2, color = "black") +
  scale_x_continuous(limits = c(-1, 3000)) +
  scale_y_continuous(limits = c(-1, 3000)) +
  labs(title = "Data Distribution - bed_fact.csv", x = "# of Staffed Beds", y = "Frequency") +
  theme_minimal()

```

```{r, tidy}

# Tidy data if necessary

```

```{r, create_db}

# Add data to a new database for downstream SQL queries
# Establish and open connection to existing database file
p2_connection <- dbConnect(RSQLite::SQLite(), "p2_db.sqlite")

# Function to check if table already exists in p2_db
table_exists <- function(con, table_name) {
  query <- sprintf("SELECT name FROM sqlite_master WHERE type='table' AND name='%s';", table_name)
  result <- dbGetQuery(con, query)
  return(nrow(result) > 0)
}

# Create bed_type_table, if it doesn't already exist
if (!table_exists(p2_connection, "bed_type_table")) {
  dbExecute(p2_connection, "
    CREATE TABLE bed_type_table (
      bed_id INTEGER PRIMARY KEY,
      bed_code TEXT,
      bed_desc TEXT
    );
  ")
}

# Create bed_fact_table, if it doesn't already exist
if (!table_exists(p2_connection, "bed_fact_table")) {
  dbExecute(p2_connection, "
    CREATE TABLE bed_fact_table (
      ims_org_id TEXT,
      bed_id INTEGER,
      license_beds INTEGER,
      census_beds INTEGER,
      staffed_beds INTEGER,
      PRIMARY KEY (ims_org_id, bed_id)
    );
  ")
}

# Create business_table, if it doesn't already exist
if (!table_exists(p2_connection, "business_table")) {
  dbExecute(p2_connection, "
    CREATE TABLE business_table (
      ims_org_id TEXT,
      business_name TEXT,
      ttl_license_beds INTEGER,
      ttl_census_beds INTEGER,
      ttl_staffed_beds INTEGER,
      bed_cluster_id INTEGER,
      PRIMARY KEY (ims_org_id, bed_cluster_id)
    );
  ")
}

# Load data into each table
dbWriteTable(p2_connection, "bed_type_table", bed_type_df, overwrite = TRUE, row.names = FALSE)
dbWriteTable(p2_connection, "bed_fact_table", bed_fact_df, overwrite = TRUE, row.names = FALSE)
dbWriteTable(p2_connection, "business_table", business_df, overwrite = TRUE, row.names = FALSE)

```

* bed_fact_table, bed_type_table, and business_table are loaded from their corresponding R dataframes

``` {r, combined table}
# Create combined_table, if it doesn't already exist
if (!table_exists(p2_connection, "combined_table")) {
  dbExecute(p2_connection, "
    CREATE TABLE combined_table (
      ims_org_id TEXT,
      business_name TEXT,
      ttl_license_beds INTEGER,
      ttl_census_beds INTEGER,
      ttl_staffed_beds INTEGER,
      bed_cluster_id INTEGER,
      bed_id INTEGER,
      license_beds INTEGER,
      census_beds INTEGER,
      staffed_beds INTEGER,
      bed_code TEXT,
      bed_desc TEXT,
      PRIMARY KEY (ims_org_id, bed_id)
    );
  ")
  # Insert data from other db tables
  dbExecute(p2_connection, "
    INSERT INTO combined_table
    SELECT business_table.ims_org_id,
           business_table.business_name,
           business_table.ttl_license_beds,
           business_table.ttl_census_beds,
           business_table.ttl_staffed_beds,
           business_table.bed_cluster_id,
           bed_fact_table.bed_id,
           bed_fact_table.license_beds,
           bed_fact_table.census_beds,
           bed_fact_table.staffed_beds,
           bed_type_table.bed_code,
           bed_type_table.bed_desc
    FROM business_table
    JOIN bed_fact_table ON business_table.ims_org_id = bed_fact_table.ims_org_id
    JOIN bed_type_table ON bed_fact_table.bed_id = bed_type_table.bed_id;
  ")
}

# Create combined dataframe
combined_df <- dbGetQuery(p2_connection, "SELECT * FROM combined_table")
head(combined_df)
str(combined_df)

```

* combined_table is loaded from the existing db tables and then loaded into combined_df

```{r, check_composite_pks}

# Verify the uniqueness of the composite primary keys used in bed_fact_table (combination of ims_org_id and bed_id) and business_table (combination of ims_org_id and bed_cluster_id)

duplicate_keys <- dbGetQuery(connection, "
                             SELECT ims_org_id, bed_id, COUNT(*)
                             FROM bed_fact_table
                             GROUP BY ims_org_id, bed_id
                             HAVING COUNT(*) > 1;
                             ")

if (nrow(duplicate_keys) == 0) {
  print("Composite PK is unique for all combinations of ims_org_id and bed_id in bed_fact_table.")
} else {
  print("Duplicate keys found in bed_fact_table !! Composite PK is not valid.")
  print(duplicate_keys)
}

duplicate_keys <- dbGetQuery(connection, "
                             SELECT ims_org_id, bed_cluster_id, COUNT(*)
                             FROM business_table
                             GROUP BY ims_org_id, bed_cluster_id
                             HAVING COUNT(*) > 1;
                             ")

if (nrow(duplicate_keys) == 0) {
  print("Composite PK is unique for all combinations of ims_org_id and bed_cluster_id in business_table.")
} else {
  print("Duplicate keys found in business_table !! Composite PK is not valid.")
  print(duplicate_keys)
}

```

###  Identification of Dimensions in bed_type.csv and business.csv

```{r}
str(bed_type_df)
str(business_df)
```

* bed_type_df contains three dimensions that are qualitative attributes providing context for or categorizing a fact object:
  * bed_id (primary key) assigns a unique identifier for each type of bed
  * bed_code contains abbreviations for each type of bed
  * bed_desc contains descriptions of each type of bed

* business_df contains three dimensions that are qualitative attributes providing context for or categorizing a fact object:
  * ims_org_id (primary key) assigns a unique identifier for each business
  * business_name contains the names of the organizations
  * bed_cluster_id categorizes bed clusters from 1-9
* The remaining columns ttl_license_beds, ttl_census_beds, and ttl_staffed_beds are facts due to their quantitative nature 

### Identification of Fact Variables in bed_fact.csv

* bed_fact_df has one dimension that is qualitative nature:
  * ims_org_id (primary key) is a dimension as it assigns unique identifier for each business  
* bed_fact_df has for facts: 
  * Bed_id, license_bed, census_bed, staffed_bed are all facts due to the numerical data  

### Initial Analysis for Leadership

```{r, license_beds_separate}
# Thomas

```

```{r, census_beds_separate}
# Sairah

```

```{r, staffed_beds_separate}
staffed_beds_separate <- "SELECT business_table.business_name AS hospital_name,
                                 --- Take the sum of the staffed beds in a new column total_icu_sicu_staffed_beds ---
                                 SUM(bed_fact_table.staffed_beds) AS total_icu_sicu_staffed_beds
                          FROM business_table
                          --- Inner join bed_fact_table with business_table on ims_org_id ---
                          JOIN bed_fact_table ON business_table.ims_org_id = bed_fact_table.ims_org_id
                          --- Only include rows where bed_id is 4 (ICU) or 15 (SICU) ---
                          WHERE bed_fact_table.bed_id IN (4, 15)
                          --- Group by hospital_name ---
                          GROUP BY business_table.business_name
                          --- Arrange in descending order ---
                          ORDER BY total_icu_sicu_staffed_beds DESC
                          --- Only include top 10 hospitals ---
                          LIMIT 10;"

dbGetQuery(p2_connection, staffed_beds_separate)
```

* bed_fact_table contains information about the hospital beds:
  * ims_org_id
  * bed_id
  * staffed_beds
* business_table contains information about the hospitals
  * ims_org_id
  * business_name
* We use ims_org_id as the condition for the inner join to find what hospitals contain ICU and SICU beds

### Interpretation of Findings (Pt. 1)


### Follow-up Analysis for Leadership (identifying hospitals with both ICU and SICU volume sufficiency)

```{r, license_beds_combined}
# Thomas

```

```{r, census_beds_combined}
# Sairah

```

```{r, staffed_beds_combined}
# Caitlin

```

### Interpretation of Findings (Pt. 2)

TODO

### Final Recommendation

TODO
